/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package core.schedule.ui;

import core.schedule.task.Task;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.GradientPaint;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Paint;
import java.awt.Point;
import java.awt.event.ActionListener;
import javax.swing.BorderFactory;
import javax.swing.JComponent;
import javax.swing.JOptionPane;
import javax.swing.SwingConstants;
import javax.swing.border.Border;
import sas.swing.MultiLineLabel;
import sas.swing.plaf.MultiLineShadowUI;

/**
 *
 * @author kiira
 */
public class TaskPanel extends javax.swing.JPanel implements ActionListener {

    private static final Color DEFAULT_COLOR = new Color( 254, 79, 79 );
    private Color baseColor;
    private Task task;
    private ScheduleUI scheduleUI;

    /** Creates new form TaskPanel */
    public TaskPanel( ScheduleUI ui, Task task, int hoursSize,
                      int timeFraction, Color color, int direction ) {
        if ( direction != SwingConstants.HORIZONTAL
             && direction != SwingConstants.VERTICAL )
            throw new IllegalArgumentException(
                    "Solo se puede especificar HORIZONTAL o VERTICAL"
                    + " como dirección." );

        initComponents();
        this.scheduleUI = ui;
        this.task = task;
        this.baseColor = color;

        //seteamos el popup
        this.setComponentPopupMenu( jPMTask );

        //calculamos el size
        int size = Math.round(
                (float)task.getDurationInMinutes() * hoursSize / timeFraction );

        //según la dirección, creamos un borde y una diimensión diferente
        Dimension dim;
        Border border;

        if ( direction == SwingConstants.HORIZONTAL ) {
            dim = new Dimension( size, this.getPreferredSize().height );
            border = BorderFactory.createMatteBorder( 0, 0, 0, 1, Color.black );
        } else {
            dim = new Dimension( this.getPreferredSize().width, size );
            border = BorderFactory.createMatteBorder( 0, 0, 1, 0, Color.black );
        }

        //seteamos la diimensión y el borde
        this.setPreferredSize( dim );
        this.setBorder( border );

        //seteamos la descripción de la task y cambiamos el color del mismo
        this.jLDescription.setText( task.getDescription() );
        this.jLDescription.setForeground(
                ( color.getRGB() < Color.black.getRGB() / 2 )
                ? Color.white
                : Color.gray );

        //asignamos en el tooltip los horarios reales
        this.setToolTipText( String.format( "Desde las %s hasta las %s",
                                            task.getInitHour(),
                                            task.getEndHour() ) );
    }

    public TaskPanel( ScheduleUI ui, Task task, int hoursSize, int timeFraction,
                      Color color ) {
        this( ui, task, hoursSize, timeFraction, color,
              SwingConstants.VERTICAL );
    }

    public TaskPanel( ScheduleUI ui, Task task, int hoursSize, int timeFraction ) {
        this( ui, task, hoursSize, timeFraction, DEFAULT_COLOR );
    }

    public TaskPanel( int time, int hoursSize, int timeFraction, int direction ) {
        if ( direction != SwingConstants.HORIZONTAL
             && direction != SwingConstants.VERTICAL )
            throw new IllegalArgumentException(
                    "Solo se puede especificar HORIZONTAL o VERTICAL"
                    + " como dirección." );

        initComponents();

        Dimension dim;
        Border border;
        int size = Math.round( (float)time * hoursSize / timeFraction );

        if ( direction == SwingConstants.HORIZONTAL ) {
            dim = new Dimension( size, this.getPreferredSize().height );
            border = BorderFactory.createMatteBorder( 0, 0, 0, 1, Color.black );
        } else {
            dim = new Dimension( this.getPreferredSize().width, size );
            border = BorderFactory.createMatteBorder( 0, 0, 1, 0, Color.black );
        }

        this.setPreferredSize( dim );
        this.setBorder( border );
    }

    public TaskPanel( int time, int hoursSize, int timeFraction ) {
        this( time, hoursSize, timeFraction, SwingConstants.VERTICAL );
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings ( "unchecked" )
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jPMTask = new javax.swing.JPopupMenu();
        jMIEliminar = new javax.swing.JMenuItem();
        jLDescription = new sas.swing.MultiLineLabel();

        jPMTask.setName("jPMTask"); // NOI18N

        jMIEliminar.setText("Eliminar");
        jMIEliminar.setName("jMIEliminar"); // NOI18N
        jMIEliminar.addActionListener(this);
        jPMTask.add(jMIEliminar);

        setLayout(new java.awt.BorderLayout());

        jLDescription.setUI( MultiLineShadowUI.labelUI );
        jLDescription.setHorizontalTextAlignment(MultiLineLabel.CENTER);
        jLDescription.setName("jLDescription"); // NOI18N
        jLDescription.setVerticalTextAlignment(MultiLineLabel.CENTER);
        add(jLDescription, java.awt.BorderLayout.CENTER);
    }

    // Code for dispatching events from components to event handlers.

    public void actionPerformed(java.awt.event.ActionEvent evt) {
        if (evt.getSource() == jMIEliminar) {
            TaskPanel.this.jMIEliminarActionPerformed(evt);
        }
    }// </editor-fold>//GEN-END:initComponents

    private void jMIEliminarActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMIEliminarActionPerformed
        if ( JOptionPane.showConfirmDialog( (JComponent)scheduleUI,
                                            "¿Desea eliminar la Task?",
                                            "Eliminar Task",
                                            JOptionPane.YES_NO_OPTION,
                                            JOptionPane.QUESTION_MESSAGE )
             == JOptionPane.YES_OPTION )
            this.scheduleUI.removeTask( this.task );
    }//GEN-LAST:event_jMIEliminarActionPerformed

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private sas.swing.MultiLineLabel jLDescription;
    private javax.swing.JMenuItem jMIEliminar;
    private javax.swing.JPopupMenu jPMTask;
    // End of variables declaration//GEN-END:variables

    @Override
    protected void paintComponent( Graphics g ) {
        super.paintComponent( g );

        //si no hay task, no ponemos ningún color
        if ( this.task == null )
            return;

        //casteamos el graphics
        Graphics2D g2 = (Graphics2D)g;

        //generamos el gradiente y lo asignamos        
        Color firstColor = this.baseColor.brighter();
        Color secondColor = this.baseColor.darker();

        Paint gradient = new GradientPaint(
                new Point( 0, this.getHeight() * 1 / 4 ), firstColor,
                new Point( 0, this.getHeight() ), secondColor );

        g2.setPaint( gradient );

        //pintamos
        g2.fillRect( 0, 0, this.getWidth(), this.getHeight() );

        //dibujamos un borde del color base
        g2.setPaint( this.baseColor );

        g2.drawLine( 0, 0, 0, this.getHeight() - 1 );
        g2.drawLine( 0, 0, this.getWidth() - 1, 0 );
        g2.drawLine( 0, this.getHeight() - 1, this.getWidth() - 1,
                     this.getHeight() - 1 );
        g2.drawLine( this.getWidth() - 1, 0, this.getWidth() - 1,
                     this.getHeight() - 1 );
    }

}
